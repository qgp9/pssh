#!/usr/bin/env perl

use strict;
use warnings;
use IO::File;
use Getopt::Long;
use v5.010;

### CUSTOM CONFIGURATION
my $O_SSH_DIR     = "$ENV{HOME}/.ssh";
my $O_SSH_CONFIG  = "$ENV{HOME}/.ssh/config";

my $PSSH_DIR    = "$O_SSH_DIR/pssh";
my $PSSH_CONFIG = "$PSSH_DIR/.ssh_config";

my $PSSH_BAK    = "$PSSH_DIR/backup";
my $PSSH_TMP    = "$PSSH_DIR/tmp";

my $editor      = $ENV{EDIT_COMMAND} || $ENV{EDITOR};
my $indent      = ' ' x 2;

my %custom_command = (
);
my @custom_options = (
);

### Let's Start!!
### Site Configuration
my $config_string = '';
my @option_template = ( 'config|c=s', 'h|help');
my @options_string = qw/-c --config -h --help/;
my @options_string2 = (
  [ [qw/-c --config/], 'Use custom pssh config file' ],
  [ [qw/-h --help/],   'Display Help' ],
);

my %commands = (

  'cat'         => [ \&pssh_cat, 
    "Print Pssh config file" 
  ],

  'path'        => [ sub { print "$PSSH_DIR\n"}, 
    "Print Path of pssh directory" 
  ],

  'key_deploy'  => [ \&pssh_key_deploy,
    "Deploy pub key to ssh server : pssh key_deploy <server> <file>"
  ],

  'edit'     => [ sub { system($editor,$PSSH_CONFIG); },
    "Edit Pssh config file" 
  ],

  'install'  => [ sub { build_config() and write_config() }, 
    "Install Pssh config file to $O_SSH_CONFIG"
  ],

  #'list'     => [ sub { print_host_list(); },
  'test'     => [ sub {  build_config() and print $config_string },
    "Compile $PSSH_CONFIG and print on screen"
  ],
  #'view'       => sub {},
);

my $command_path = {
  config=>[],
  -default=>'config',
  -description=>'Print Some',
  -help=>'',
};

#### Control completion command in the begining
if( @ARGV > 0 ){
  if( $ARGV[0] eq 'completion' ){
    shift @ARGV;
    my $COMP_CWORD = $ENV{COMP_CWORD} ;
    my $cur = '';
    $cur = pop @ARGV if $COMP_CWORD != $#ARGV || $ARGV[-1]=~/^\s*/;
    if ( $cur =~ /^-/ ){
      /^$cur/ and print $_," " for @options_string;
    }elsif( $ARGV[-1] =~ /^(-c|--config)$/ ){
      print join ' ', map{ -d && "$_/\n" || $_ }glob "'$cur*'";
    }else{
      print join ' ',grep { /^$cur/ } keys %commands;
    }
    exit 0;
  }
  if( $ARGV[0] eq 'bash_completion_template' ){
    pssh_bash_completion_template();
    exit 0;
  }
}

#### Site Variables
my @config_data;
my @config_lines;
my %variables;
my %configs;
my @configs;

sub _do_what_config {
  my $cb = shift or die $!;
  open my $in_fh, '<'. $PSSH_CONFIG or die $!,' ',$PSSH_CONFIG;
  $cb->($in_fh);
  close $in_fh;
}

sub build_config {
  open my $in_fh, '<'. $PSSH_CONFIG or die $!,' ',$PSSH_CONFIG;
  while( $_ = <$in_fh> ){

    /^\s*\+/            #### Dummy :ines
      and next; 

    /^\s*\$\w+\s*=/     #### Variable
      and parse_variable($in_fh,$_)
      and next;

    s/(\$\{(\w+)\})/defined $variables{$2}?$variables{$2}:$1/ge;
    s/(\$(\w+))/defined $variables{$2}?$variables{$2}:$1/ge;

    s/^\s*(\|\s*)*-+//;
    s/^\s*(\|\s*)*#/#/;

    /^\s*\|/            #### Data Lines
      and $config_string .= parse_data_line($_) 
      and next;

    ### Anything Else
    $config_string .= $_;
  }
  close $in_fh;
}

sub write_config{
  ### Make backup Directory
  use File::Path;
  unless( -d $PSSH_BAK ){
    File::Path::make_path($PSSH_BAK) or die $!,' ',$PSSH_BAK;
  }
  ### Make Backup file
  use File::Copy;
  copy( $O_SSH_CONFIG, $PSSH_BAK.'/config-'.time.'.bak' ) or die "Copy failed: $!";

  ### Write
  open my $out_fh, '>', $O_SSH_CONFIG or die "$! $O_SSH_CONFIG";
  print $out_fh $config_string if $config_string;
  close $out_fh;
}

sub parse_data_line {
  shift;
  my $config_string;
  ### manipulate comments
  my ( $data, $comments ) = (/([^#]*)(.*)/g);

  ### manipulate data
  my ( $host, $address, $idkey, $options ) = (
    $data =~ /^\s*\|\s*([^|\s]*)[\s\|]*([^\|\s]*)[\s\|]*([^|\s]*)[\s\|]*(.*)/msg
  );

  ### manipulate server info
  my ( $user, $hostname, $port ) = (
    $address =~ /\s*(?:(\S+)@)?(\[.+?\]|[^:]+)(?::(\d+))?/g
  );

  ### At least, $hostname should be
  die "wrong sintext at $.\n$_\n" unless  $hostname ;

  ### if a server alias isn't
  unless( $host ){
    $host = $hostname;
    $hostname = undef;
  }

  $idkey='' if  defined $idkey && $idkey eq 'x'  ;

  $config_string .= $comments."\n"                   if $comments;
  $config_string .= "Host $host\n";
  $config_string .= "${indent}HostName $hostname\n"  if $hostname;
  $config_string .= "${indent}User $user\n"          if $user;
  $config_string .= "${indent}Port $port\n"          if $port;
  $config_string .= "${indent}IdentityFile $idkey\n" if $idkey;
  $config_string .= $options                         if $options;

  my $conf = {
    Host      => $host, 
    HostName  => $hostname,
    User      => $user,
    Port      => $port,
    IdentityFile => $idkey,
    options      => $options,
  };
  $configs{$address} = $conf;
  push @configs, $conf;

  return $config_string;

}

sub parse_variable {
  my $in_fh = shift;
  shift;
  /\s*\$(\w+)\s*=\s*\{(.*)\}/
    and $variables{$1}=$2
    and return 1;
  /\s*\$(\w+)\s*=\s*\{(.*)/ and do {
    my $vname = $1;
    my $vstr  = $2.''?$2."\n":'';
    while ( $_=<$in_fh> ){
      /\s*\}/ and last;
      /(\s*.+)\}/ and $vstr.=$1 and last;
      $vstr.=$_;
    }
    $variables{$vname} = $vstr;
    return 1;
  };
  /\s*\$(\w+)\s*=\s*(.*)/ 
    and $variables{$1}=$2
    and return 1;
}

sub get_host_list {
  build_config unless %configs;
  return sort { $configs{$a}{Host} cmp $configs{$b}{Host} }  keys %configs;
}

sub print_host_list {
  my @list = get_host_list;
  for ( @list ){
    my $c = $configs{$_};
    my $u = $c->{User};
    my $p = $c->{Port};
    my $hh = $c->{HostName};
    $u  = $u ? $u.'@' : '';
    $p  = $p ? ':'.$p : '';
    $hh = $hh ? $hh.$p : $c->{Host}.$p;
    printf "%10s%-30s%s\n", $u, $c->{Host}, $hh;
  }
}

sub usage{
  print "# usage : pssh <command> <options> \n";
  print "# Commands\n";
  for ( sort keys %commands ){
    my $val = $commands{$_};
    my $type = ref $val;
    my $des = sprintf "    %-10s : ",$_;;
    $des .= $val->{description}||'' if 'HASH' eq $type;
    $des .= $val->[1]||'' if 'ARRAY' eq $type;
    print $des,"\n";
  }
  print "# Options\n";
  for( @options_string2 ){
    printf "    %-20s : %s\n", join(' ',@{$_->[0]}), $_->[1];
  }
}

sub pssh_bash_completion_template {
  print q|function _pssh_completion { export COMP_CWORD COMP_POINT COMP_LINE;COMPREPLY=( $(pssh completion "${COMP_WORDS[@]}" ) ); }; complete -o nospace -F _pssh_completion pssh |;
}

sub pssh_cat {
  my $file = shift || $PSSH_CONFIG;
  my $fh = IO::File->new($PSSH_CONFIG,'r'); 
  print <$fh>;
}

sub pssh_key_deploy {
  my ( $server, $key ) = @_;
  my ( $D, $A ) =qw'~/.ssh ~/.ssh/authorized_keys';
  print( qq{cat $key | ssh $server "mkdir -p $D && cat >> $A"},"i\n" );
  system( qq{cat $key | ssh $server "mkdir -p $D && cat >> $A"} );
}




if( @ARGV > 0 ){
  #say Dumper \@ARGV;
  my %option;
  my @com;
  Getopt::Long::Configure ("bundling");
  GetOptions (\%option,
    @option_template,
    '<>'=>sub{
      push @com, @_;
    }
  );
  #say Dumper \%option, \@com, \@ARGV;
  if( $option{config} ){
    $PSSH_CONFIG = $option{config};
    die "ERROR : $PSSH_CONFIG doesn't exists." unless -e $PSSH_CONFIG;
  }

  my $com = shift @com;

  ## Check command
  unless( $com && exists $commands{$com} ){
    usage();
    exit 1;
  }
  if( $option{h} ){
    usage();
    exit 0;
  }

  if( $commands{$com} ){
    my $command = $commands{$com};
    my $type = ref $command;
    if( 'CODE' eq $type ){ 
      $command->(@ARGV);
    }elsif ( 'HASH' eq $type ){
      $command->{command}->(@ARGV);
    }elsif ( 'ARRAY' eq $type ){
      $command->[0]->(@ARGV);
    }
    exit;
  }

  #system $editor, $PSSH_CONFIG;
}
